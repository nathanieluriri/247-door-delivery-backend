# ============================================================================
# RATING REPOSITORY
# ============================================================================
# This file was auto-generated on: 2025-12-09 09:41:13 WAT
# It contains asynchronous functions for managing access to the database
# in a MongoDB database using FastAPI.
#
# DO NOT EDIT THIS FILE MANUALLY - RE-RUN THE GENERATOR INSTEAD. OR IF YOU WANT TO EDIT JUST ADD LEAVE OTHER FUNCTIONS THE WAY YOU MET THEM
# ============================================================================

from pymongo import ReturnDocument
from core.database import db
from fastapi import HTTPException,status
from typing import List,Optional
from schemas.rating import RatingSummary, RatingUpdate, RatingCreate, RatingOut

async def create_rating(rating_data: RatingCreate) -> RatingOut:
    rating_dict = rating_data.model_dump()
    result =await db.ratings.insert_one(rating_dict)
    result = await db.ratings.find_one(filter={"_id":result.inserted_id})
    returnable_result = RatingOut(**result)
    return returnable_result

async def get_rating(filter_dict: dict) -> Optional[RatingOut]:
    try:
        result = await db.ratings.find_one(filter_dict)

        if result is None:
            return None

        return RatingOut(**result)

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred while fetching rating: {str(e)}"
        )
        
        
        
async def get_user_rating_summary(user_id: str) -> RatingSummary:
    try:
        pipeline = [
            {"$match": {"userId": user_id}},
            {
                "$group": {
                    "_id": None,
                    "avgRating": {"$avg": "$rating"},
                    "totalRides": {"$sum": 1}
                }
            }
        ]

        cursor = db.ratings.aggregate(pipeline)
        result_list = await cursor.to_list(length=1)

        # No ratings found â†’ return 0 averages
        if not result_list:
            return RatingSummary(avgRating=0, totalRides=0)

        result = result_list[0]

        return RatingSummary(
            avgRating=result.get("avgRating", 0),
            totalRides=result.get("totalRides", 0)
        )

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Failed to retrieve user rating summary: {str(e)}"
        )
    
async def get_ratings(filter_dict: dict = {},start=0,stop=100) -> List[RatingOut]:
    try:
        if filter_dict is None:
            filter_dict = {}

        cursor = (db.ratings.find(filter_dict)
        .skip(start)
        .limit(stop - start)
        )
        rating_list = []

        async for doc in cursor:
            rating_list.append(RatingOut(**doc))

        return rating_list

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred while fetching ratings: {str(e)}"
        )
async def update_rating(filter_dict: dict, rating_data: RatingUpdate) -> RatingOut:
    result = await db.ratings.find_one_and_update(
        filter_dict,
        {"$set": rating_data.model_dump(exclude_none=True)},
        return_document=ReturnDocument.AFTER
    )
    returnable_result = RatingOut(**result)
    return returnable_result

async def delete_rating(filter_dict: dict):
    return await db.ratings.delete_one(filter_dict)
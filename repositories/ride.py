# ============================================================================
# RIDE REPOSITORY
# ============================================================================
# This file was auto-generated on: 2025-12-09 17:57:12 WAT
# It contains asynchronous functions for managing access to the database
# in a MongoDB database using FastAPI.
#
# DO NOT EDIT THIS FILE MANUALLY - RE-RUN THE GENERATOR INSTEAD. OR IF YOU WANT TO EDIT JUST ADD LEAVE OTHER FUNCTIONS THE WAY YOU MET THEM
# ============================================================================

from pymongo import ReturnDocument
from core.database import db
from fastapi import HTTPException,status
from typing import List,Optional
from schemas.ride import RideUpdate, RideCreate, RideOut




async def check_if_user_has_an_existing_active_ride(user_id:str):
    active_statuses = ["arrivingToPickup","drivingToDestination","pendingPayment"]
    existing_ride = await db.rides.find_one({
        "userId": user_id, 
        "rideStatus": {"$in": active_statuses}
    })
    if existing_ride:
        raise HTTPException(
            status_code=400, 
            detail=f"You still have an active ride ({existing_ride['rideStatus']}). Please complete or cancel it first."
        )



async def create_ride(ride_data: RideCreate) -> RideOut:
    ride_dict = ride_data.model_dump()

    result =await db.rides.insert_one(ride_dict)
    result = await db.rides.find_one(filter={"_id":result.inserted_id})
    returnable_result = RideOut(**result)
    return returnable_result

async def get_ride(filter_dict: dict) -> Optional[RideOut]:
    if not filter_dict:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Ride filter is required."
        )
    try:
        result = await db.rides.find_one(filter_dict)

        if result is None:
            return None

        return RideOut(**result)

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred while fetching ride: {str(e)}"
        )
    
async def get_rides(filter_dict: Optional[dict] = None,start=0,stop=100) -> List[RideOut]:
    try:
        filter_dict = filter_dict or {}
        start = max(0, start or 0)
        if stop is None:
            stop = start + 100
        limit = max(0, stop - start)

        cursor = (db.rides.find(filter_dict)
        .skip(start)
        .limit(limit)
        )
        ride_list = []

        async for doc in cursor:
            ride_list.append(RideOut(**doc))

        return ride_list

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred while fetching rides: {str(e)}"
        )
async def update_ride(filter_dict: dict, ride_data: RideUpdate) -> RideOut:
    if not filter_dict:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Ride filter is required."
        )
    update_doc = ride_data.model_dump(exclude_none=True)
    if not update_doc:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="No ride fields to update."
        )
    result = await db.rides.find_one_and_update(
        filter_dict,
        {"$set": update_doc},
        return_document=ReturnDocument.AFTER
    )
    if result is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ride not found."
        )
    returnable_result = RideOut(**result)
    return returnable_result

async def delete_ride(filter_dict: dict):
    from bson import ObjectId
    from bson.errors import InvalidId

    if not filter_dict:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Ride filter is required."
        )

    if "_id" in filter_dict and isinstance(filter_dict["_id"], str):
        try:
            
            filter_dict["_id"] = ObjectId(filter_dict["_id"])
        except InvalidId:
            
            pass 

    result = await db.rides.delete_one(filter_dict)
    if result.deleted_count == 0:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Ride not found."
        )
    return result
